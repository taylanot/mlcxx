/**
 * @file datagen_impl.h
 * @author Ozgur Taylan Turan
 *
 * A simple toy data generation interface
 *
 * TODO: Increase the dimensionality, add some classification datasets banana??
 * TODO: Maybe add a base class for datagen
 * TODO: Maybe Functional data generation can be done with each_row()
 *
 *
 */
#ifndef DATAGEN_IMPL_H
#define DATAGEN_IMPL_H

namespace utils {
namespace data {
namespace regression {

  Dataset::Dataset( ) { }
  Dataset::Dataset( const size_t& D, const size_t& N ) :
                                                    size(N), dimension(D) { }

  void Dataset::Set ( const size_t& D, const size_t& N)
  {
    size_ = N;
    dimension_ = D;
  }

  void Dataset::Generate( const double& scale, const& double phase,
                          const std::string& type )
  {
    if (type == "Linear")
    {
      inputs_ = arma::randn(dimension_,size_) + phase;
      labels_ = (scale*arma::ones(dimension_)).t() * inputs_;
    }
    else if (type == "Sine")
    {
      inputs_ = arma::randn(dimension_,size_) + phase;
      labels_ =   (scale*arma::ones(dimension_)).t() * arma::sin(inputs_);
    }
  }

  void Dataset::Generate( const double scale, const double phase,
                          const std::string type, const double noise_std )
  {
      this -> Generate(scale, phaese, type);
      this -> Noise(noise_std);
  }

  void Dataset::Generate( const size_t& M, const std::string& type )
  {
    BOOST_ASSERT_MSG( dimension_ == 1, "FunctionalData input dim. != 1!");
    labels_.resize(M,size);  

    if (type == "SineFunctional")
    {
      inputs_ = arma::sort(arma::randn(dimension_,size_),"ascend",1);
      arma::rowvec phase(M,arma::fill::randn);
      for( size_t i=0; i<M; i++ )
         labels_.row(i) = arma::sin(inputs_+phase(i));
    }
  }
  void Dataset::Generate( const size_t& M, const std::string& type,
                                           const arma::rowvec& noise_std )
  {
    this -> Generate(M, type);
    this -> Noise( noise_std ); 
  }

  void Dataset::Noise ( const double& noise_std )
  {
     this -> Noise( 1, noise_std);
  }

  void Dataset::Noise ( const size_t& M, const double& noise_std )
  {
      arma::rowvec noise = arma::randn(M,size_)%noise_std;
      labels_.each_row() += noise;
  }


  void Dataset::Save(const std::string& filename)
  {
    arma::mat data = arma::join_cols(inputs, labels);
    utils::Save(filename, data, true);
  }

} // namespace regression
} // namespace data
} // namespace utils

//namespace utils {
//namespace data {
//namespace regression {
//
//  SineGen::SineGen( ) { }
//  SineGen::SineGen(size_t M)
//  {
//    this -> size = M;
//
//    this -> a = arma::rowvec(size, arma::fill::randn);
//    this -> p = arma::rowvec(size, arma::fill::randn);
//  }
//
//  arma::mat SineGen::Predict(arma::mat inputs, std::string type) const 
//  {
//    arma::mat labels(size, inputs.n_cols);
//    if (type == "Phase")
//    {
//      for (size_t i=0; i<size; i++)
//        labels.row(i) = arma::sin(inputs+p(i));
//      return labels;
//    }
//    else if (type == "Amplitude")
//    {
//      for (size_t i=0; i<size; i++)
//        labels.row(i) = a(i) * arma::sin(inputs);
//      return labels;
//    }
//    else
//    {
//      for (size_t i=0; i<size; i++)
//        labels.row(i) = a(i)*arma::sin(inputs+p(i));
//      return labels;
//    }
//  }
//
//} // namespace regression
//} // namespace data
//} // namespace utils


#endif
